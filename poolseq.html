<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>PoPoolation Pipeline</title>

<script src="site_libs/header-attrs-2.20/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="tutorial.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">MarineOmics</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="contributions.html">Contributions</a>
</li>
<li>
  <a href="panels.html">Panel Seminars</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Population Genomics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="choosing-population-genetics.html">Choosing a Population Genomics Approach</a>
    </li>
    <li>
      <a href="WGS_intro.html">Whole Genome Resequencing</a>
    </li>
    <li>
      <a href="RADseq.html">Reduced Representation Sequencing</a>
    </li>
    <li>
      <a href="poolseq.html">Poolseq</a>
    </li>
    <li>
      <a href="RDAtraitPredictionTutorial.html">Redundancy Analysis (RDA) Trait Prediction</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Functional Genomics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="DGE_comparison_v2.html">Mutifactorial RNAseq</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Genome-Phenome
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">coming soon!</li>
  </ul>
</li>
<li>
  <a href="https://github.com/MarineOmics/marineomics.github.io/discussions">Discussion Forum</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-53GH9PV49T', 'auto');
  ga('send', 'pageview');

</script>

<div id="header">



<h1 class="title toc-ignore">PoPoolation Pipeline</h1>
<h3 class="subtitle"><em>Joanna Griffiths</em></h3>
<h4 class="date">8/12/2021</h4>

</div>


<p>I mostly followed the PoPoolation and PoPoolation2 pipelines by
Robert Kofler and Christian Schlötterer (<a
href="https://sourceforge.net/p/popoolation2/wiki/Main/"
class="uri">https://sourceforge.net/p/popoolation2/wiki/Main/</a>). The
website has an easy-to-follow tutorial for using PoPoolation2 and how to
use their scripts. This pipeline extends the use of the scripts for
running on a Linux cluster. I highly recommend following the
PoPoolation2 tutorial and manual and using these scripts if you have any
modifications from default flags. *Note: These scripts were written for
use on Louisiana State University’s high performance cluster
“SuperMike-II” running Red Hat Enterprise Linux 6 (more info found here:
<a
href="http://www.hpc.lsu.edu/resources/hpc/system.php?system=SuperMike-II"
class="uri">http://www.hpc.lsu.edu/resources/hpc/system.php?system=SuperMike-II</a>)</p>
<p>The following scripts were used to analyze data from an experimental
evolution study on <em>Tigriopus californicus</em> copepods <span
class="citation">(Griffiths, Kawji, and Kelly 2020)</span>. Raw
sequencing data are deposited in NCBI’s Short Reads Archive (<a
href="https://www.ncbi.nlm.nih.gov/bioproject/PRJNA597336/"
class="uri">https://www.ncbi.nlm.nih.gov/bioproject/PRJNA597336/</a>).
To download this dataset, go to: <a
href="https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=run_browser"
class="uri">https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=run_browser</a>
, then type in the accession number for the identified files you want to
download (e.g., the accession no. for the file Bodega population file is
SRR10760095, identified under the “Run” heading). Then click on the
“Data access” tab, and there will be a downloadable link. Additional
analyses and scripts can be found at: <a
href="https://github.com/JoannaGriffiths/Tigriopus_HER"
class="uri">https://github.com/JoannaGriffiths/Tigriopus_HER</a></p>
<p><strong><em>Strengths and weaknesses of Pool-seq</em></strong><br />
Due to the nature of Pool-seq where multiple individuals are pooled to
prepare a single library, this results in a loss of haplotype
information. Therefore, analyses rely on allele frequency estimates
rather than hard “genotype calls”. PoPoolation2 is primarily used for
comparing allele frequency differences between populations or treatments
in comparison to a reference genome. The pooling of many individuals can
be a cost-effective tool to characterize genetic variation present at
the population level (e.g., genome wide association studies and
experimental evolution). For example, to identify small changes in
allele frequencies, you would need to genotype hundreds of individuals
across the entire genome, which may be too cost-prohibitive with
individual barcoding. However, individual genotype information is lost,
as well as information on dominance and effect sizes. For example,
individual genotypes cannot be linked to individual phenotypes.
Additionally, estimations of linkage disequilibrium are limited to a
single sequencing read since that is the known limit of haplotype
information for a single individual. Finally, distinguishing between
sequencing errors and rare, low-frequency alleles is limited. Unlike
sequencing of individuals, this cannot be solved by analyzing multiple
reads from the same region of a single chromosome. One way to ameliorate
this issue is to sequence replicates of pools. In addition, Pool-seq
analyses can be prone to inaccurate estimations of allele frequencies
based on the experimental methods. Care must be taken to ensure the the
experimental design maximizes the ratio sequencing coverage to the
number of individuals pooled.</p>
<p><strong><em>Notes on Experimental Design for Downstream
Analyses:</em></strong><br />
It is important to try to standardize the number of individuals (and
thus DNA) pooled for each sample. Robert Kofler and team also recommend
that the pool size should be larger than the goal coverage for
sequencing, because this minimizes re-sampling the same allele from a
single individual several times. Because PoPoolation is designed for
comparing differences in allele frequencies among treatments/population,
accuracy will depend on the pool size and sequencing coverage. For
example, smaller differences in allele frequency changes can be seen if
you have a large number of individuals in a single pool and more
coverage. The PoPoolation2 Manual page provides the following
calculation to detect significant allele frequency differences:"To
detect a significant (Fisher’s exact test; p=0.01) allele frequency
difference between two populations of 30%, a coverage (and pool size) of
50 will be sufficient. If however significant (Fisher’s exact test;
p=0.01) allele frequency differences of 10% need to be detected the
coverage as well as the pool size should be about 400.”<br />
It is critical to note, the sequencing accuracy of Pool-seq increases
with larger pool sizes; if the number of sequenced individuals is
approximately equal to the coverage, then the sequency accuracy is no
longer superior to an individual level of sequencing (see Fig. 1a from
<span class="citation">(Schlötterer et al. 2014)</span>).</p>
<p><strong><em>Alternative Pipelines</em></strong><br />
Low Coverage Pool-seq <a href="Data:\" class="uri">Data:\</a> <a
href="https://github.com/petrov-lab/HAFpipe-line"
class="uri">https://github.com/petrov-lab/HAFpipe-line</a><br />
Alternative pipelines have been created for low coverage (&lt;5x)
pool-seq data that can provide accurate estimates of allele frequencies.
This pipeline is designed for Evolve and Re-sequence studies where the
founder haplotypes are known.</p>
<p>Customizable Filtering and Assessing Quality of Pool-Seq <a
href="Data:\" class="uri">Data:\</a> <a
href="https://github.com/ToBoDev/assessPool"
class="uri">https://github.com/ToBoDev/assessPool</a><br />
This pipeline filters SNPs based on adjustable criterion with
suggestions for pooled data. It determines pool number and prepares
proper data structure for analysis, creates a customizable run script
for Popoolation2 for all pairwise comparisons, runs Popoolation2 and
poolfstat, imports Popoolation2 and poolfstat output, and finally,
generates population genetic statistics and plots for data
visualization.</p>
<div id="filter-raw-sequences" class="section level2">
<h2>Filter Raw Sequences</h2>
<p>The script below uses the wrapper TrimGalore to remove
Adapter/Barcode sequences and removes poor quality reads. This example
dataset uses paired end sequencing so I used the flag (–paired) in
TrimGalore. Because these example files had high coverage, I was able to
use conservative filters. For example, the default length of reads is 20
bp (so if a read is less than 20 bp then the read will be removed).
Since I had high coverage and long read lengths (150 bp), I used a
minimum read length of 40 bp. The –max_n flag specifies how many “Ns”
can be in the read before the read if discarded as “poor quality”.
Again, depending on your sequencing depth you may want to be more or
less conservative. There is no default value specified in TrimGalore,
but I used a highly conservative value of 1 (ie any instances of N in
the read and that read will be discarded). This is probably more
conservative than you need to be, because the read may still contain
informative sequencing data. Please note that these parameters are not
specific to a Pool Seq dataset.</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q checkpt
#PBS -A hpc_kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=72:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N trimgalore_Tigs

date

#Go to the directory where the raw sequencing files are located
cd /work/jgrif61/Tigs/raw_data/raw

trim_galore --paired --length 40 --max_n 1 Tig-1S_S6_L008_R1_001.fastq.gz Tig-1S_S6_L008_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-1U_S3_L001_R1_001.fastq.gz Tig-1U_S3_L001_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-2S_S7_L008_R1_001.fastq.gz  Tig-2S_S7_L008_R2_001.fastq.gz  -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-2U_S9_L008_R1_001.fastq.gz Tig-2U_S9_L008_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-3S_S1_L001_R1_001.fastq.gz Tig-3S_S1_L001_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-4S_S2_L001_R1_001.fastq.gz Tig-4S_S2_L001_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-4U_S10_L008_R1_001.fastq.gz Tig-4U_S10_L008_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-5S_S8_L008_R1_001.fastq.gz Tig-5S_S8_L008_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-5U_S4_L001_R1_001.fastq.gz Tig-5U_S4_L001_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-6U_S11_L008_R1_001.fastq.gz Tig-6U_S11_L008_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-BR_S5_L001_R1_001.fastq.gz Tig-BR_S5_L001_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
trim_galore --paired --length 40 --max_n 1 Tig-SD_S12_L008_R1_001.fastq.gz Tig-SD_S12_L008_R2_001.fastq.gz -o /work/jgrif61/Tigs/raw_data/raw
date
exit 0</code></pre>
</div>
<div id="map-reads-to-reference-genome" class="section level2">
<h2>Map Reads to Reference Genome</h2>
<pre class="bash"><code>#!/bin/bash

#PBS -q workq
#PBS -A hpc_kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=72:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N bowtie_tigs_BRSD

cd /work/jgrif61/Tigs/raw_data/raw

#prepare and index the reference genome so you can map reads to it
bowtie2-build reference/full_genome_mito_tigs.fasta reference/reference_index

bowtie2 -x ../reference/reference_index -1 Tig-1S_S6_L008_R1_001_val_1.fq.gz -2 Tig-1S_S6_L008_R2_001_val_2.fq.gz -S 1S_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-1U_S3_L001_R1_001_val_1.fq.gz -2 Tig-1U_S3_L001_R2_001_val_2.fq.gz -S 1U_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-2S_S7_L008_R1_001_val_1.fq.gz -2 Tig-2S_S7_L008_R2_001_val_2.fq.gz -S 2S_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-2U_S9_L008_R1_001_val_1.fq.gz -2 Tig-2U_S9_L008_R2_001_val_2.fq.gz -S 2U_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-3S_S1_L001_R1_001_val_1.fq.gz -2 Tig-3S_S1_L001_R2_001_val_2.fq.gz -S 3S_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-4S_S2_L001_R1_001_val_1.fq.gz -2 Tig-4S_S2_L001_R2_001_val_2.fq.gz -S 4S_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-4U_S10_L008_R1_001_val_1.fq.gz -2 Tig-4U_S10_L008_R2_001_val_2.fq.gz -S 4U_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-5S_S8_L008_R1_001_val_1.fq.gz -2 Tig-5S_S8_L008_R2_001_val_2.fq.gz -S 5S_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-5U_S4_L001_R1_001_val_1.fq.gz -2 Tig-5U_S4_L001_R2_001_val_2.fq.gz -S 5U_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-6U_S11_L008_R1_001_val_1.fq.gz -2 Tig-6U_S11_L008_R2_001_val_2.fq.gz -S 6U_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-BR_S5_L001_R1_001_val_1.fq.gz -2 Tig-BR_S5_L001_R2_001_val_2.fq.gz -S BR_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-SD_S12_L008_R1_001_val_1.fq.gz -2 Tig-SD_S12_L008_R2_001_val_2.fq.gz -S SD_out_PE.sam

bowtie2 -x ../reference/reference_index -1 Tig-allU_R1_001_val1_new.fq -2 Tig-allU_R2_001_val2_new.fq -S allU_out_PE.sam



#turn mapped sam files into bam file and then sort and remove ambiguously mapped reads
samtools view -bS 1S_out_PE.sam | samtools sort -o 1S_out.sorted
samtools view -bS 1U_out_PE.sam | samtools sort -o 1U_out.sorted
samtools view -bS 2S_out_PE.sam | samtools sort -o 2S_out.sorted
samtools view -bS 2U_out_PE.sam | samtools sort -o 2U_out.sorted
samtools view -bS 3S_out_PE.sam | samtools sort -o 3S_out.sorted
samtools view -bS 4S_out_PE.sam | samtools sort -o 4S_out.sorted
samtools view -bS 4U_out_PE.sam | samtools sort -o 4U_out.sorted
samtools view -bS 5S_out_PE.sam | samtools sort -o 5S_out.sorted
samtools view -bS 5U_out_PE.sam | samtools sort -o 5U_out.sorted
samtools view -bS 6U_out_PE.sam | samtools sort -o 6U_out.sorted
samtools view -bS BR_out_PE.sam | samtools sort -o BR_out.sorted
samtools view -bS SD_out_PE.sam | samtools sort -o SD_out.sorted
samtools view -bS allU_out_PE.sam | samtools sort -o allU_out.sorted

date 
exit</code></pre>
</div>
<div id="determine-mean-coverage-across-the-genome"
class="section level2">
<h2>Determine mean coverage across the genome</h2>
<p>This code can be used to determine the mean coverage across the
genome for each sample/library. This information can be used to inform
the min and max coverage used in downstream analyses (such as the
Fisher’s exact test and Fst analyses). You will want to choose a min and
max coverage window spanning the mean coverage.</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q workq
#PBS -A hpc_kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=24:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N coverage

cd /work/jgrif61/Tigs/raw_data/raw
/home/jgrif61/samtools-1.13/samtools coverage 1S_out.sorted -o 1S.coverage
/home/jgrif61/samtools-1.13/samtools coverage 1U_out.sorted -o 1U.coverage
/home/jgrif61/samtools-1.13/samtools coverage 2S_out.sorted -o 2U.coverage
/home/jgrif61/samtools-1.13/samtools coverage 3S_out.sorted -o 3S.coverage
/home/jgrif61/samtools-1.13/samtools coverage 4S_out.sorted -o 4S.coverage
/home/jgrif61/samtools-1.13/samtools coverage 4U_out.sorted -o 4U.coverage
/home/jgrif61/samtools-1.13/samtools coverage 5S_out.sorted -o 5S.coverage
/home/jgrif61/samtools-1.13/samtools coverage 5U_out.sorted -o 5U.coverage
/home/jgrif61/samtools-1.13/samtools coverage 6U_out.sorted -o 6U.coverage
/home/jgrif61/samtools-1.13/samtools coverage BR_out.sorted -o BR.coverage
/home/jgrif61/samtools-1.13/samtools coverage SD_out.sorted -o SD.coverage
/home/jgrif61/samtools-1.13/samtools coverage allU_out.sorted -o allU.coverage

date 
exit</code></pre>
</div>
<div id="compiling-snps-for-all-samples" class="section level2">
<h2>Compiling SNPs for all samples</h2>
<p>This script compiles all the identified SNPs for each sample into a
matrix. This sync file format is required for downstream analyses such
as Fst, creating Manhattan plots, or CMH tests to be used in both the
PoPoolation and PoPoolation2 pipelines. You will want to make sure that
the –fastq-type flag is set to “sanger” (this is for Phred quality score
matching–yes, this is correct even if you used Illumina sequencing). The
min-qual flag must be above 0, the default is 20 which gives you a 99%
base call accuracy rate).</p>
<p><strong>What is an Mpileup file?</strong><br />
Pileup format is a text-based format for summarizing the base calls of
aligned reads to a reference sequence. This format facilitates visual
display of SNP/indel calling and alignment. (Source: Wikipedia)</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q checkpt
#PBS -A hpc_kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=72:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N mpileup

cd /work/jgrif61/Tigs/raw_data/raw

samtools mpileup -f full_genome_mito_tigs.fasta 1S_out.sorted 1U_out.sorted 2S_out.sorted 2U_out.sorted 3S_out.sorted 4S_out.sorted 4U_out.sorted 5S_out.sorted 5U_out.sorted 6U_out.sorted BR_out.sorted SD_out.sorted &gt; all_indiv.mpileup

perl /work/jgrif61/Tigs/popoolation2_1201/mpileup2sync.pl --fastq-type sanger --min-qual 20 --input all_indiv.mpileup --output all_indiv.sync

#Alternative code for generation sync file that is 78x faster
java -ea -Xmx7g -jar /work/jgrif61/Tigs/popoolation2_1201/mpileup2sync.jar --input all_indiv.mpileup --output all_indiv_java.sync --fastq-type sanger --min-qual 20 --threads 8

#Making mpileup files for each sample. Can be used for calculating nucleotide diversity for each sample.
samtools mpileup -f full_genome_mito_tigs.fasta 1S_out.sorted BR_out.sorted &gt; 1S.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 1U_out.sorted &gt; 1U.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 2S_out.sorted &gt; 2S.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 1U_out.sorted &gt; 2U.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 3S_out.sorted &gt; 3S.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 4S_out.sorted &gt; 4S.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 4U_out.sorted &gt; 4U.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 5S_out.sorted &gt; 5S.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 5U_out.sorted &gt; 5U.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta 6U_out.sorted &gt; 6U.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta BR_out.sorted &gt; BR.mpileup
samtools mpileup -f full_genome_mito_tigs.fasta SD_out.sorted &gt; SD.mpileup
</code></pre>
<p>Sample of a synchronized file:</p>
<pre class="bash"><code>2  2302    N   0:7:0:0:0:0 0:7:0:0:0:0
2  2303    N   0:8:0:0:0:0 0:8:0:0:0:0
2  2304    N   0:0:9:0:0:0 0:0:9:0:0:0
2  2305    N   1:0:9:0:0:0 0:0:9:1:0:0</code></pre>
<ul>
<li>col1: reference contig</li>
<li>col2: position within the refernce contig</li>
<li>col3: reference character</li>
<li>col4: allele frequencies of population number 1</li>
<li>col5: allele frequencies of population number 2</li>
<li>coln: allele frequencies of population number n</li>
</ul>
<p>The allele frequencies are in the format A:T:C:G:N:del, i.e: count of
bases ‘A’, count of bases ‘T’,… and deletion count in the end (character
’*’ in the mpileup)</p>
</div>
<div id="pop-gen-and-downstream-statistical-analyses"
class="section level2">
<h2>Pop Gen and Downstream Statistical Analyses</h2>
<p>These in-depth notes are not on the tutorial or manual page, but
detailed descriptions for each flag can be found using the
<code>--help</code> option when running each script.
e.g. <code>perl fst-sliding.pl --help</code></p>
<p>You will want to play around with the min-coverage, max-coverage, and
min-count based on the mean coverage of your samples/populations.
Minimum coverages that are too high and max coverages that are too low
may result in an empty output file, which is why it’s a good idea to
have an estimate of your mean/min/max coverage for each
sample/population. The minimum count must be less than the minimum
coverage. You may want to modify this flag based on the number of
individuals pooled per sample/population.</p>
<p><strong><em>Important considerations:</em></strong><br />
<code>--suppress-noninformative</code>: Output files will not report
results for windows with no SNPs or insufficient coverage. Including
this flag will make it easier for downstream manipulation of the output
file, such as creating figures.</p>
<p><code>--pool-size</code>: the number of individuals pooled per
sample; If the pool sizes differ among each sample, you can provide the
size for each sample individually: –pool-size 500 .. all
samples/populations have a pool size of 500 –pool-size 500:300:600 ..
first sample/population has a pool size of 500, the second of 300
etc;</p>
<p><code>--min-coverage</code>: the minimum coverage used for SNP
identification, the coverage in ALL samples/populations has to be higher
or equal to this threshold, otherwise no SNP will be called.
default=4</p>
<p><code>--max-coverage</code>: The maximum coverage; All populations
are required to have coverages lower or equal than the maximum coverage;
Mandatory.<br />
The maximum coverage may be provided as one of the following:<br />
<code>500</code> a maximum coverage of 500 will be used for all
samples/populations<br />
<code>300,400,500</code> a maximum coverage of 300 will be used for the
first sample/population, a maximum coverage of 400 for the second
sample/population and so on<br />
<code>2%</code> the 2% highest coverages will be ignored, this value is
independently estimated for every sample/population</p>
<p><strong><em>NOTE ABOUT MAX COVERAGE</em></strong><br />
When genotyping individually barcoded samples, max coverage requirements
are generally not recommended. However, pool-seq analyses require a max
coverage for calculating Fst, cmh, allele frequency changes, etc.
because allele frequency estimates are based on the number allele count,
which are prone to PCR duplicates. PCR duplicates from a single
individual in the pool may skew allele frequency estimates.</p>
<p><code>--min-covered-fraction</code>:the minimum fraction of a window
being between min-coverage and max-coverage in ALL samples/populations;
float; default=0.0<br />
The tutorial provides an example script with a min-covered fraction of
1, however, you will most likely run into an error or an empty output
file. The min-covered-fraction flag must be smaller than 1: this flag
defines what percent of the window must meet the requirements
(e.g. flags: min-count, min-coverage, max-coverage). It is most likely
impossible that your entire sequencing window will meet all of these
requirements (unless of course you chose a window size of 1 bp!).</p>
<p><code>--min-count</code>: the minimum count of the minor allele, used
for SNP identification. SNPs will be identified considering all
samples/populations simultaneously. default=2. The minimum count MUST be
smaller than the min-coverage flag for this script to run.</p>
</div>
<div id="calculate-sliding-window-fst" class="section level2">
<h2>Calculate sliding window Fst</h2>
<p>This script will calculate Fst pair-wise comparisons for all
samples.</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q workq
#PBS -A hpc_Kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=4:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N stats

date

cd /work/jgrif61/Tigs/raw_data

perl /work/jgrif61/Tigs/popoolation2_1201/fst-sliding.pl --input all_indiv.sync --output all_PE_w10000_step10000.fst --suppress-noninformative --min-count 5 --min-coverage 20 --max-coverage 200 --min-covered-fraction 0.2 --window-size 10000 --step-size 10000 --pool-size 100

date
exit
</code></pre>
<p>The following R script can be used to plot Fst results in a Manhattan
plot</p>
<pre class="r"><code>library(&quot;qqman&quot;)
library(&quot;DataCombine&quot;)

fst = read.table(&quot;all_PE_w10000_step10000.fst&quot;, header = T) 
fst &lt;- fst[c(&quot;CHR&quot;, &quot;BP&quot;, &quot;X1.11&quot;, &quot;X1.12&quot;, &quot;X2.11&quot;, &quot;X2.12&quot;, &quot;X3.11&quot;, &quot;X3.12&quot;, &quot;X4.11&quot;, &quot;X4.12&quot;, &quot;X5.11&quot;, &quot;X5.12&quot;, &quot;X6.11&quot;, &quot;X6.12&quot;, &quot;X7.11&quot;, &quot;X7.12&quot;, &quot;X8.11&quot;, &quot;X8.12&quot;, &quot;X9.11&quot;, &quot;X9.12&quot;, &quot;X10.11&quot;, &quot;X10.12&quot;, &quot;X11.12&quot;)] #rename column headers
fst$ID &lt;- paste(fst$CHR,fst$BP,sep=&quot;.&quot;)

#tidying file
Replaces &lt;- data.frame(from=c(&quot;Chromosome_&quot;), to=c(&quot;&quot;))
fst2 &lt;- FindReplace(data = fst, Var = &quot;CHR&quot;, replaceData = Replaces,
                       from = &quot;from&quot;, to = &quot;to&quot;, exact = FALSE)
fst2$CHR &lt;- as.numeric(fst2$CHR)

manhattan(fst2, chr=&quot;CHR&quot;, bp=&quot;BP&quot;, snp=&quot;ID&quot;, p=&quot;X1.11&quot;, suggestiveline = F, genomewideline = F, logp = F, ylim =c(0,1)) #p here refers to pvalue or in this case the Fst value, substitute with which column comparison you are interested in graphing</code></pre>
<div class="figure">
<img src="images/Fst_SvsBR_SDmap.png" alt="" />
<p class="caption">Manhattan plot of mean Fst values for 10,000-bp
windows of all the selected lines versus the pure Bodega population.</p>
</div>
</div>
<div id="calculate-fishers-exact-test" class="section level2">
<h2>Calculate Fisher’s Exact Test</h2>
<p>This script will calculate significant allele frequency differences
for each SNP position between two samples. Results can be plotted in a
Manhattan plot. Depending on the experimental method, the
<code>--window-summary-method</code> flag can be used to determine
p-value for windows of SNPs. The default is to multiply the p-value of
all SNPs for the window. Alternatively, you can specify how p-values
within a window should be summarized. Options include multiply,
geometric mean, or median. The summary of p-values within a window is
dependent on the experimental design and how recent selection was
expected to occur. For example, the default parameter might be
appropriate if your treatment comparisons are geographically separated
populations, where selection is expected to have occurred over hundreds
of thousands of years. However, this might be inappropriate for
short-term experimental evolution studies, such as the example dataset
here. In this dataset, copepods were selected in the lab for 15-20
generations, therefore, we expect relatively large linkage blocks that
prevent us from identifying the true targets of selection, and therefore
I use the geometric mean option.</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q workq
#PBS -A hpc_Kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=4:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N stats

date

cd /work/jgrif61/Tigs/raw_data


perl /work/jgrif61/Tigs/popoolation2_1201/fisher-test.pl --input all_indiv.sync --output all_indiv.fet --suppress-noninformative --min-count 2 --min-coverage 20 --max-coverage 200 --min-covered-fraction 0.2 --window-summary-method geometricmean
</code></pre>
<p>You may need to run the following code on the command line (not in
the queues) to install twotailed perl Module before running
Fisher-test.pl. See LSU HPC for details: <a
href="http://www.hpc.lsu.edu/docs/faq/installation-details.php"
class="uri">http://www.hpc.lsu.edu/docs/faq/installation-details.php</a></p>
<pre class="bash"><code>perl -MCPAN -e &#39;install Text::NSP::Measures::2D::Fisher2::twotailed&#39;</code></pre>
</div>
<div id="calculate-exact-allele-frequencies-in-samples"
class="section level2">
<h2>Calculate Exact Allele Frequencies in Samples</h2>
<p>Exact allele frequencies can be used to determine differences in
allele frequencies among populations or before and after a selection
experiment, for example. These result could be plotted in a PCA or
Manhattan plot.</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q workq
#PBS -A hpc_Kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=4:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N stats

date

cd /work/jgrif61/Tigs/raw_data

perl /work/jgrif61/Tigs/popoolation2_1201/snp-frequency-diff.pl --input all_indiv.sync --output-prefix all_indiv --min-count 6 --min-coverage 20 --max-coverage 200

date
exit
</code></pre>
<p>This script creates two output files having two different
extensions:</p>
<p><code>_rc</code>: this file contains the major and minor alleles for
every SNP in a concise format <code>_pwc</code>: this file contains the
differences in allele frequencies for every pairwise comparision of the
populations present in the synchronized file For details see the man
pages of the script The allele frequency differences can be found in the
<code>_pwc</code> file, a small sample:</p>
<pre class="bash"><code>##chr   pos     rc      allele_count    allele_states   deletion_sum    snp_type        most_variable_allele    diff:1-2
2      4459    N       2       C/T     0       pop     T       0.133
2      9728    N       2       T/C     0       pop     T       0.116</code></pre>
<p>The last column contains the obtained differences in allele
frequencies for the allele provided in column 8. Note that in this
example the last column refers to a pairwise comparison between
population 1 vs 2, in case several populations are provided all pairwise
comparisons will be appended in additional columns.</p>
</div>
<div id="cochran-mantel-haenszel-cmh-test" class="section level2">
<h2>Cochran-Mantel-Haenszel (CMH) test</h2>
<p>This script will detect consistent allele frequency changes in
biological replicates. In my case, I was comparing selected samples to
one control sample, but if you have replicates of treatments and
controls, you can compare columns 1-2, 3-4, etc.</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q workq
#PBS -A hpc_Kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=4:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N stats

date

cd /work/jgrif61/Tigs/raw_data 

#perl /work/jgrif61/Tigs/popoolation2_1201/cmh-test.pl --input all_indiv.sync_for_cmh --output all_perl_PE_2.cmh --min-count 12 --min-coverage 50 --max-coverage 200 --population 1-6,2-6,3-6,4-6,5-6

date
exit</code></pre>
<p>Due to constraints of the test, you can only compare allele frequency
changes for individual SNPs and not windows. I expected high levels of
linkage disequilibrium in my samples because individuals were exposed to
strong selection pressure. Depending on the amount of linkage
disequilibrium you expect in your populations, you may want to account
for the non-independence of SNPs following the CMH test. One way to do
this, would be to calculate the mean (or geometric mean) p-value for all
SNPs in a window. I provide some example R code below for how to do
this. I used the program SeqMonk to map cmh results to the genome and an
annotated genome file I created with probes for the desired window size
(i.e. 10,000 bp). Output files from SeqMonk will tell you which 10,000
bp window a particular SNP falls into. Thus, SNPs can be grouped for
each 10,000bp window on each chromosome.</p>
<pre class="r"><code>library(&quot;psych&quot;)

cmh &lt;-read.table(&quot;10000window_BR_cmh_overlap.txt&quot;, header=TRUE)
cmh &lt;- cmh[c(1,2,3,4,6)] #Keeping only the columns I care about
cmh$ID &lt;- paste(cmh$Chromosome,cmh$Start,sep=&quot;.&quot;) #creating an ID column so each SNP location is tied to its chromosome

cmh_p &lt;-read.table(&quot;Tig.cmh&quot;, header=TRUE) #read in the original output from the CMH test, because SeqMonk output discards the important p-value column.
colnames(cmh_p) &lt;- c(&quot;CHR&quot;, &quot;BP&quot;, &quot;Allele&quot;, &quot;1S&quot;, &quot;2S&quot;, &quot;3S&quot;, &quot;4S&quot;, &quot;5S&quot;, &quot;U&quot;, &quot;p&quot;) #rename columns based on sample names
cmh_p$ID &lt;- paste(cmh_p$CHR,cmh_p$BP,sep=&quot;.&quot;)
cmh_p &lt;- cmh_p[c(10,11)]

cmh_all &lt;- merge(cmh, cmh_p, by=&quot;ID&quot;, all = TRUE)

#Now we can calculate the geometric mean for each window one chromosome at a time
library(&quot;EnvStats&quot;)
chr1&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_1&quot;,]
Chr1_ave &lt;- aggregate(p~FeatureID, data=chr1, FUN=function(x) c(mean=geoMean(x)))
Chr1_ave$CHR &lt;- rep(1,nrow(Chr1_ave))
Chr1_ave$CHR2 &lt;- rep(&quot;Chromosome_1&quot;,nrow(Chr1_ave))


chr2&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_2&quot;,]
Chr2_ave &lt;- aggregate(p~FeatureID, data=chr2, FUN=function(x) c(mean=geoMean(x)))
Chr2_ave$CHR &lt;- rep(2,nrow(Chr2_ave))
Chr2_ave$CHR2 &lt;- rep(&quot;Chromosome_2&quot;,nrow(Chr2_ave))

chr3&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_3&quot;,]
Chr3_ave &lt;- aggregate(p~FeatureID, data=chr3, FUN=function(x) c(mean=geoMean(x)))
Chr3_ave$CHR &lt;- rep(3,nrow(Chr3_ave))
Chr3_ave$CHR2 &lt;- rep(&quot;Chromosome_3&quot;,nrow(Chr3_ave))

chr4&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_4&quot;,]
Chr4_ave &lt;- aggregate(p~FeatureID, data=chr4, FUN=function(x) c(mean=geoMean(x)))
Chr4_ave$CHR &lt;- rep(4,nrow(Chr4_ave))
Chr4_ave$CHR2 &lt;- rep(&quot;Chromosome_4&quot;,nrow(Chr4_ave))

chr5&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_5&quot;,]
Chr5_ave &lt;- aggregate(p~FeatureID, data=chr5, FUN=function(x) c(mean=geoMean(x)))
Chr5_ave$CHR &lt;- rep(5,nrow(Chr5_ave))
Chr5_ave$CHR2 &lt;- rep(&quot;Chromosome_5&quot;,nrow(Chr5_ave))

chr6&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_6&quot;,]
Chr6_ave &lt;- aggregate(p~FeatureID, data=chr6, FUN=function(x) c(mean=geoMean(x)))
Chr6_ave$CHR &lt;- rep(6,nrow(Chr6_ave))
Chr6_ave$CHR2 &lt;- rep(&quot;Chromosome_6&quot;,nrow(Chr6_ave))

chr7&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_7&quot;,]
Chr7_ave &lt;- aggregate(p~FeatureID, data=chr7, FUN=function(x) c(mean=geoMean(x)))
Chr7_ave$CHR &lt;- rep(7,nrow(Chr7_ave))
Chr7_ave$CHR2 &lt;- rep(&quot;Chromosome_7&quot;,nrow(Chr7_ave))

chr8&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_8&quot;,]
Chr8_ave &lt;- aggregate(p~FeatureID, data=chr8, FUN=function(x) c(mean=geoMean(x)))
Chr8_ave$CHR &lt;- rep(8,nrow(Chr8_ave))
Chr8_ave$CHR2 &lt;- rep(&quot;Chromosome_8&quot;,nrow(Chr8_ave))

chr9&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_9&quot;,]
Chr9_ave &lt;- aggregate(p~FeatureID, data=chr9, FUN=function(x) c(mean=geoMean(x)))
Chr9_ave$CHR &lt;- rep(9,nrow(Chr9_ave))
Chr9_ave$CHR2 &lt;- rep(&quot;Chromosome_9&quot;,nrow(Chr9_ave))

chr10&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_10&quot;,]
Chr10_ave &lt;- aggregate(p~FeatureID, data=chr10, FUN=function(x) c(mean=geoMean(x)))
Chr10_ave$CHR &lt;- rep(10,nrow(Chr10_ave))
Chr10_ave$CHR2 &lt;- rep(&quot;Chromosome_10&quot;,nrow(Chr10_ave))

chr11&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_11&quot;,]
Chr11_ave &lt;- aggregate(p~FeatureID, data=chr11, FUN=function(x) c(mean=geoMean(x)))
Chr11_ave$CHR &lt;- rep(11,nrow(Chr11_ave))
Chr11_ave$CHR2 &lt;- rep(&quot;Chromosome_11&quot;,nrow(Chr11_ave))

chr12&lt;- cmh_all[cmh_all$Chromosome == &quot;Chromosome_12&quot;,]
Chr12_ave &lt;- aggregate(p~FeatureID, data=chr12, FUN=function(x) c(mean=geoMean(x)))
Chr12_ave$CHR &lt;- rep(12,nrow(Chr12_ave))
Chr12_ave$CHR2 &lt;- rep(&quot;Chromosome_12&quot;,nrow(Chr12_ave))


cmh_p_ave_allchr &lt;- rbind(Chr1_ave, Chr2_ave, Chr3_ave, Chr4_ave, Chr5_ave, Chr6_ave, Chr7_ave,Chr8_ave, Chr9_ave, Chr10_ave, Chr11_ave, Chr12_ave)

library(tidyr)
cmh_p_ave_allchr2 &lt;- separate(cmh_p_ave_allchr, FeatureID, c(&quot;BP_start&quot;, &quot;BP_end&quot;))
cmh_p_ave_allchr2$BP_start &lt;- as.numeric(cmh_p_ave_allchr2$BP_start)
cmh_p_ave_allchr2$BP_ID &lt;- paste(cmh_p_ave_allchr2$BP_start + 5000) #I wanted the window ID to start in the middle of the window
cmh_p_ave_allchr2$ID &lt;- paste(cmh_p_ave_allchr2$CHR,cmh_p_ave_allchr2$BP_start,sep=&quot;.&quot;)

write.table(cmh_p_ave_allchr2, file = &quot;cmh_window_geomean_p&quot;, sep = &quot;\t&quot;)</code></pre>
<p>I then analyzed the results of the CMH test by plotting the geometric
mean for each 10,000bp window on a Manhattan plot.</p>
</div>
<div id="popoolation-pipelines-for-analyses" class="section level2">
<h2>PoPoolation Pipelines for analyses</h2>
</div>
<div id="nucleotide-diversity" class="section level2">
<h2>Nucleotide Diversity</h2>
<p>Calculate Pi (nucleotide diversity) for individual samples. Use
mpileup files that were created for a single sample as the input. Below
is an example for one sample.</p>
<pre class="bash"><code>#!/bin/bash

#PBS -q workq
#PBS -A hpc_Kelly_19_3
#PBS -l nodes=1:ppn=16
#PBS -l walltime=4:00:00
#PBS -o /work/jgrif61/Tigs/output_files
#PBS -j oe
#PBS -M jgrif61@lsu.edu
#PBS -N stats

date

cd /work/jgrif61/Tigs/raw_data 

perl /work/jgrif61/Tigs/popoolation_1.2.2/Variance-sliding.pl --measure pi --input 1S.mpileup --output 1S.pi --min-count 2 --min-coverage 10 --max-coverage 200 --window-size 10000 --step-size 10000 --pool-size 100 --fastq-type sanger 


date
exit
</code></pre>
<p>I used nucleotide diversity for creating a PCA plot to compare
genetic diversity among my samples and to look for broad patterns across
my data and I ran an Adonis test to determine if there were significant
differences among groups (in this example, selected vs control
lines)</p>
<pre class="r"><code>#import each pi file and do some cleanup:
pi_1S &lt;- read.delim(&quot;1S.pi&quot;, header = F)
colnames(pi_1S) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_1S&quot;)
pi_1S$ID &lt;- paste(pi_1S$Chromosome, pi_1S$window, sep = &#39;_&#39;)
pi_1S &lt;- pi_1S[!pi_1S$pi_1S == &quot;na&quot;,] #remove rows with na
pi_1S &lt;- pi_1S[,c(6,5)]

pi_1U &lt;- read.delim(&quot;1U.pi&quot;, header = F)
colnames(pi_1U) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_1U&quot;)
pi_1U$ID &lt;- paste(pi_1U$Chromosome, pi_1U$window, sep = &#39;_&#39;)
pi_1U &lt;- pi_1U[!pi_1U$pi_1U == &quot;na&quot;,]
pi_1U &lt;- pi_1U[,c(6,5)]

pi_2S &lt;- read.delim(&quot;2S.pi&quot;, header = F)
colnames(pi_2S) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_2S&quot;)
pi_2S$ID &lt;- paste(pi_2S$Chromosome, pi_2S$window, sep = &#39;_&#39;)
pi_2S &lt;- pi_2S[!pi_2S$pi_2S == &quot;na&quot;,] #remove rows with na
pi_2S &lt;- pi_2S[,c(6,5)]

pi_2U &lt;- read.delim(&quot;2U.pi&quot;, header = F)
colnames(pi_2U) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_2U&quot;)
pi_2U$ID &lt;- paste(pi_2U$Chromosome, pi_2U$window, sep = &#39;_&#39;)
pi_2U &lt;- pi_2U[!pi_2U$pi_2U == &quot;na&quot;,]
pi_2U &lt;- pi_2U[,c(6,5)]

pi_3S &lt;- read.delim(&quot;3S.pi&quot;, header = F)
colnames(pi_3S) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_3S&quot;)
pi_3S$ID &lt;- paste(pi_3S$Chromosome, pi_3S$window, sep = &#39;_&#39;)
pi_3S &lt;- pi_3S[!pi_3S$pi_3S == &quot;na&quot;,] #remove rows with na
pi_3S &lt;- pi_3S[,c(6,5)]

pi_4S &lt;- read.delim(&quot;4S.pi&quot;, header = F)
colnames(pi_4S) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_4S&quot;)
pi_4S$ID &lt;- paste(pi_4S$Chromosome, pi_4S$window, sep = &#39;_&#39;)
pi_4S &lt;- pi_4S[!pi_4S$pi_4S == &quot;na&quot;,] #remove rows with na
pi_4S &lt;- pi_4S[,c(6,5)]

pi_4U &lt;- read.delim(&quot;4U.pi&quot;, header = F)
colnames(pi_4U) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_4U&quot;)
pi_4U$ID &lt;- paste(pi_4U$Chromosome, pi_4U$window, sep = &#39;_&#39;)
pi_4U &lt;- pi_4U[!pi_4U$pi_4U == &quot;na&quot;,]
pi_4U &lt;- pi_4U[,c(6,5)]

pi_5S &lt;- read.delim(&quot;5S.pi&quot;, header = F)
colnames(pi_5S) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_5S&quot;)
pi_5S$ID &lt;- paste(pi_5S$Chromosome, pi_5S$window, sep = &#39;_&#39;)
pi_5S &lt;- pi_5S[!pi_5S$pi_5S == &quot;na&quot;,] #remove rows with na
pi_5S &lt;- pi_5S[,c(6,5)]

pi_5U &lt;- read.delim(&quot;5U.pi&quot;, header = F)
colnames(pi_5U) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_5U&quot;)
pi_5U$ID &lt;- paste(pi_5U$Chromosome, pi_5U$window, sep = &#39;_&#39;)
pi_5U &lt;- pi_5U[!pi_5U$pi_5U == &quot;na&quot;,]
pi_5U &lt;- pi_5U[,c(6,5)]

pi_6U &lt;- read.delim(&quot;6U.pi&quot;, header = F)
colnames(pi_6U) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_6U&quot;)
pi_6U$ID &lt;- paste(pi_6U$Chromosome, pi_6U$window, sep = &#39;_&#39;)
pi_6U &lt;- pi_6U[!pi_6U$pi_6U == &quot;na&quot;,]
pi_6U &lt;- pi_6U[,c(6,5)]

pi_SD &lt;- read.delim(&quot;SD.pi&quot;, header = F)
colnames(pi_SD) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_SD&quot;)
pi_SD$ID &lt;- paste(pi_SD$Chromosome, pi_SD$window, sep = &#39;_&#39;)
pi_SD &lt;- pi_SD[!pi_SD$pi_SD == &quot;na&quot;,]
pi_SD &lt;- pi_SD[,c(6,5)]

pi_BR &lt;- read.delim(&quot;BR.pi&quot;, header = F)
colnames(pi_BR) &lt;- c(&quot;Chromosome&quot;, &quot;window&quot;, &quot;num.snps&quot;, &quot;frac&quot;, &quot;pi_BR&quot;)
pi_BR$ID &lt;- paste(pi_BR$Chromosome, pi_BR$window, sep = &#39;_&#39;)
pi_BR &lt;- pi_BR[!pi_BR$pi_BR == &quot;na&quot;,]
pi_BR &lt;- pi_BR[,c(6,5)]


#merge all pi results into one file
pi_all1 &lt;- merge(pi_1S, pi_1U, by=&quot;ID&quot;)
pi_all2 &lt;- merge(pi_all1, pi_2S, by=&quot;ID&quot;)
pi_all3 &lt;- merge(pi_all2, pi_2U, by=&quot;ID&quot;)
pi_all4 &lt;- merge(pi_all3, pi_3S, by=&quot;ID&quot;)
pi_all5 &lt;- merge(pi_all4, pi_4S, by=&quot;ID&quot;)
pi_all6 &lt;- merge(pi_all5, pi_4U, by=&quot;ID&quot;)
pi_all7 &lt;- merge(pi_all6, pi_5S, by=&quot;ID&quot;)
pi_all8 &lt;- merge(pi_all7, pi_5U, by=&quot;ID&quot;)
pi_all9 &lt;- merge(pi_all8, pi_6U, by=&quot;ID&quot;)
pi_all10 &lt;- merge(pi_all9, pi_SD, by=&quot;ID&quot;)
pi_all &lt;- merge(pi_all10, pi_BR, by=&quot;ID&quot;)

pi_all$pi_1S &lt;- as.numeric(pi_all$pi_1S)
pi_all$pi_1U &lt;- as.numeric(pi_all$pi_1U)
pi_all$pi_2S &lt;- as.numeric(pi_all$pi_2S)
pi_all$pi_2U &lt;- as.numeric(pi_all$pi_2U)
pi_all$pi_3S &lt;- as.numeric(pi_all$pi_3S)
pi_all$pi_4S &lt;- as.numeric(pi_all$pi_4S)
pi_all$pi_4U &lt;- as.numeric(pi_all$pi_4U)
pi_all$pi_5S &lt;- as.numeric(pi_all$pi_5S)
pi_all$pi_5U &lt;- as.numeric(pi_all$pi_5U)
pi_all$pi_6U &lt;- as.numeric(pi_all$pi_6U)
pi_all$pi_BR &lt;- as.numeric(pi_all$pi_BR)
pi_all$pi_SD &lt;- as.numeric(pi_all$pi_SD)

dds.pcoa=pcoa(vegdist(t((pi_all[,2:13])), method=&quot;euclidean&quot;)/1000)
scores=dds.pcoa$vectors
percent &lt;- dds.pcoa$values$Eigenvalues
percent / sum(percent) #percent for each axes; change in caption below

windows()
plot(scores[,1], scores[,2],
     col=c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;black&quot;, &quot;black&quot;), 
     pch = c(19,19,19,19,19,19,19,19,19,19,1,19),
     xlab = &quot;PC1 (24.33%)&quot;, ylab = &quot;PC2 (21.24%)&quot;)

treat_df &lt;- data.frame(
  ID = c(&quot;1S_pi&quot;, &quot;1U_pi&quot;, &quot;2S_pi&quot;, &quot;2U_pi&quot;, &quot;3S_pi&quot;, &quot;4S_pi&quot;, &quot;4U_pi&quot;, &quot;5S_pi&quot;, &quot;5U_pi&quot;,&quot;6U_pi&quot;),
  line = c(&quot;S&quot;, &quot;U&quot;, &quot;S&quot;, &quot;U&quot;, &quot;S&quot;, &quot;S&quot;, &quot;U&quot;, &quot;S&quot;, &quot;U&quot;, &quot;U&quot;)
)

line &lt;- treat_df$line

adonis2(t(pi_all[,2:11])~line, data = treat_df, permutations = 1000000, method = &quot;manhattan&quot;)</code></pre>
<div class="figure">
<img src="images/pi_PCA.png" alt="" />
<p class="caption">Principle coordinate analysis of allele frequencies
for selected lines (red), control lines (blue), the pure Bodega
population (white), and the pure San Diego population (black).</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Griffiths2020" class="csl-entry">
Griffiths, Joanna S, Yasmeen Kawji, and Morgan W Kelly. 2020.
<span>“<span class="nocase">An Experimental Test of Adaptive
Introgression in Locally Adapted Populations of Splash Pool
Copepods</span>.”</span> <em>Molecular Biology and Evolution</em> 38
(4): 1306–16. <a
href="https://doi.org/10.1093/molbev/msaa289">https://doi.org/10.1093/molbev/msaa289</a>.
</div>
<div id="ref-Schlotterer2014" class="csl-entry">
Schlötterer, Christian, Raymond Tobler, Robert Kofler, and Viola Nolte.
2014. <span>“<span class="nocase">Sequencing pools of individuals-mining
genome-wide polymorphism data without big funding</span>.”</span>
<em>Nature Reviews Genetics</em> 15 (11): 749–63. <a
href="https://doi.org/10.1038/nrg3803">https://doi.org/10.1038/nrg3803</a>.
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
